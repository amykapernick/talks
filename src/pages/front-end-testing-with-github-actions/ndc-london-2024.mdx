---
title: Front End Testing with GitHub Actions
layout: "../../parts/layout.astro"
config: 
  navigationMode: linear
---
import Slide from '@slides/slide'
import Notes from '@parts/notes'
import Background from '@parts/background'
import TestingTalk from './img/testing-talk.png'
import Blog from './img/blog.png'
import GitHubActions from './img/github_actions.png'
import ActionsSecret from './img/actions_secret.png'
import ActionsDashboard from './img/actions_dashboard.png'
import SuccessfulComment from './img/successful_comment.png'
import SuccessfulCommentMultiple from './img/successful_comment_multiple.png'
import PRSuccessfulAction from './img/pr_successful_action.png'
import WorkflowPermissions from './img/workflow_permissions.png'
import CSSChanges from './img/css_changes.png'
import HTMLFile from './img/html_file.png'

<Background />

<Slide>
	# {frontmatter.title}
</Slide>

<Slide>
	Why test?
	<Notes slot="notes">
		- First off, I'm not going to delve into why we need to be testing or why we need to test the front end of our applications
		- If you're here or watching this at home, I'm going to assume that you know we need to test
		- If you don't know why, or aren't convinced yet, I've got another talk for you
	</Notes>
</Slide>

<Slide 
	type="figure" 
	image={TestingTalk} 
	caption="kapers.dev/fender-testing"
>
	<Notes slot="notes">
		- In 2020 I gave a talk about the whys and hows of front end Testing
		- I did give it in London, but this will take you to the Sydney version which is a bit more updated
	</Notes>
</Slide>

<Slide>
	TLDR - You need a live website
	<Notes slot="notes">
		- When testing the front end though, we need a live website
		- Unlike running other tests, like unit tests where you can give it dummy data and confirm that the output is the same
		- For front end tests, you need to be able to have a functioning front end to test against
	</Notes>
</Slide>

<Slide
	type="background"
	image={HTMLFile}
>
	<Notes slot="notes">
		- For example, from this code snippet, can you tell me if the interface is accessible to someone with a vision impairment?
		- Can you work out how fast the page will load or if any of the resources will block the page render?
	</Notes>
</Slide>

<Slide
	type="background"
	image={CSSChanges}
>
	
	<Notes slot="notes">
		- Looking at a CSS code snippet, can you determine if any of the code changes will bleed out to another part of the application?
	</Notes>
</Slide>

<Slide>
	Front end testing needs a front end
	<Notes slot="notes">
		- As the name suggests, front end testing needs a functioning front end to test against
		- While we can perform some linting and validations against the code we've written, there's only so much we can determine without seeing the final product
		- Ideally with a setup as close to production as possible (in particular for performance testing)
	</Notes>
</Slide>

<Slide>
	Why GitHub Actions?
	<Notes slot="notes">
		- So why GitHub actions you ask? This is a great question that I want to address in 2 parts
	</Notes>
</Slide>

<Slide>
	Manual tests are ü§∑‚Äç‚ôÄÔ∏è
	<Notes slot="notes">
		- While definitely better than nothing, manual tests aren't great because it's hard to ensure that they're being run
		- How many of your enjoy doing a repetitive task that could easily be automated?
		- None of you, that's one of the things we love using AI for
	</Notes>
</Slide>

<Slide>
	Automation adds consistency
	<Notes slot="notes">
		- When tests are automated, as part of any kind of process, it means it's going to happen
		- It adds a check to make sure that we're actually running the tests
		- When the pipeline is setup properly as well, we can ensure that code that doesn't pass tests doesn't get merged in and protect the quality of our application
	</Notes>
</Slide>

<Slide>
	Why GitHub Actions?
	<Notes slot="notes">
		- But why did I choose GitHub actions to use for running tests and as my CI/CD tool?
		- The documentation and assistance available to me was good and meant it wasn't hard to get started
		- It's also compatible with a lot of existing things I was going to want to do
		- And has great extensibility so works for smaller personal projects and bigger enterprise projects
		- So while the code and conventions we're using are specific to GitHub Actions, the concepts are practices are ones that you can take and reuse with your own tools and processes
	</Notes>
</Slide>

<Slide
	type="figure"
	image={GitHubActions}
	caption="github.com/features/actions"
>
	<Notes slot="notes">
		- For those that aren't familiar with or haven't heard of GitHub Actions, which I'm going to assume aren't many of you as it's in the title of this talk
		- It's a very powerful tool that I could also do a whole talk on
		- So if you want to look into it a bit more, check out the GitHub docs or there are a few people from GitHub here this week so see if you can track on of them down
	</Notes>
</Slide>

<Slide>
	<span slot="header">Workflow Files</span>

	`.github/workflows/test.yml`
	<small>(yay `yaml`/`yml` üôÑ)</small>

	<Notes slot="notes">
		- GitHub Actions runs what are called *workflows*, which are written inside *workflow files* inside a particular folder of your project
		- As with a lot of devops tools, these files are written in yaml
	</Notes>
</Slide>

<Slide>
	Workflow <span class="fragment">‚Üí Jobs</span> <span class="fragment">‚Üí Steps</span>
	<Notes slot="notes">
		- Each workflow (or action) runs one or more jobs, by default these jobs will all run at the same time but we'll look at that a bit later on
		- Each job is made up of a number of steps, which will run one after another
	</Notes>
</Slide>

<Slide type="code" size="xs" lines={['1','3-6']}>
	```yaml
	name: Build and Test

	on:
	  pull_request:
	    types: [opened, reopened, synchronize]
	    branches: [prod]
	```
	<Notes slot="notes">
		1. Name of the Workflow
		2. How the workflow is triggered, in this case every time a pull request to the prod branch gets opened, reopened or the code in the PR gets updated
			- https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows
	</Notes>
</Slide>

<Slide type="code" size="small">
	```yaml
	on:
		create: # Create a branch or tag
		delete: # Delete a branch or tag
		deployment: # Create a deployment
		discussion: # Create/Update/Delete/etc a discussion
		fork: # Fork a repo
		issue_comment: # Create/Update/Delete a comment on an issue/PR
		project_card: # Create/Update/Delete/etc a project card
		push: # Push to a branch
		pull_request: # Create/Update/etc a PR
		push: # Push to a branch
		workflow_run: # Actions Workflow is Completed/Requested/In Progress
	```
	<Notes slot="notes">
		- There are many options of events that can trigger a workflow, these are just a few of common ones
		- Most of these actions then also allows setting config to filter down to more specific events
	</Notes>
</Slide>

<Slide type="code" size="small" lines={['3-6', '7', '8']}>
	```yaml
	on:
	  pull_request:
	    types: [assigned, unassigned, labelled, unlabelled, opened, edited, closed, 
		reopened, synchronize, ready_for_review, locked, unlocked, review_requested,
		review_request_removed, auto_merge_enabled, auto_merge_disabled,
		ready_for_auto_merge]
	    branches: [prod, development, feature/**]
		paths: ['**.js', '**.css']
	```
	<Notes slot="notes">
		- For example, the pull request trigger allows us to define the different types of events will trigger the workflow, whether all events will trigger it, or just ones that involve the code being changed (eg. opened, edited, reopened, synchronize)
		- We can also filter the specific branches, for example maybe this should just be related to the code going into production, but not something we need to consider when merging other branches into one another
		- This can include wildcard branch names as well, maybe you have branch naming conventions and want to run it against any branches that introduce a new feature
		- And we can also filter down to specific files, so maybe we only want to run this workflow when a CSS or JS file is changed
	</Notes>
</Slide>

<Slide type="code" size="small" lines={['2', '3', '4']}>
	```yaml
	on:
	  pull_request:
	    types: [opened, reopened, synchronize]
	    branches: [prod]
	```
	<Notes slot="notes">
		- But for this case we're going to keep it simple
		- We want to trigger this on pull requests
		- In particular when a pull request is opened, reopened or synchronised (so this should only run when the code in a PR is changed)
		- And we only want to run this when code is being merged into the production branch, we don't care about the code that exists on other branches just yet.
	</Notes>
</Slide>

<Slide type="code" size="xs" lines={['8', '9', '10', '11-18']}>
	```yaml
	name: Build and Test

	on:
	  pull_request:
	    types: [opened, reopened, synchronize]
	    branches: [prod]

	jobs:
	  build:
	    runs-on: ubuntu-22.04
	    steps:
	      - name: Checkout Repo Code
			uses: actions/checkout@v3

		  - name: Setup Node
	        uses: actions/setup-node@v3
	        with:
	          node-version: 18
	```
	<Notes slot="notes">
		3. The jobs/tasks that the workflow completes, by default these will all run at the same time
			- https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow
		4. Each job gets a different name, eg. `build`, but the name must be unique
		5. Set the platform that the job will run on, you can choose a number of different options, but running on Linux is the cheapest option
			- https://docs.github.com/en/actions/using-jobs/choosing-the-runner-for-a-job
		6. Each job has a number of steps to complete (these will complete one after another), most of the time your first step will be to checkout the repo code, otherwise you won't have anything to work with
	</Notes>
</Slide>

<Slide type="code" size="xs" lines={['1,6', '7', '2,8,13', '12', '9-10', '3-4,14-18']}>
	```yaml
	- name: Setup Node
	  uses: actions/setup-node@v3
	  with:
	    node-version: 16

	- name: Run Custom Script
	  id: custom_script
	  run: ./.github/actions/my_script.sh
	  env:
	    MY_ENV_VAR: ${{ secrets.MY_ENV_VAR }}

	- if: ${{ failure() }}
	  uses: actions/github-script@v6
	  with:
	    script: github.rest.issues.createComment({
			issue_number: context.issue.number,
			body: 'Whoops, something went wrong'
		  })
	```
	<Notes slot="notes">
		1. Name of the step (this is for us to identify it when it runs)
		2. A unique ID for the step, this is optional and can be used to refer to it elsewhere in the job
		3. We can define what actually happens in 2 different ways. Most of the time we use an existing actions package, using the `uses` property to define the package and version we're using. Alternatively we can run a script in the terminal, using the `run` property and defining the script/command to run
		4. Rather than running a step on 
		5. 
		6. Some actions will also require values/config to be passed in, so these are set under the `with` property
			 - Eg. for the setup node package, it can take a value of which node version you want to use and GitHub Scripts allows you to define a script to run, in this case to add a comment to our PR/issue that has triggered the action
	</Notes>
</Slide>

<Slide type="code" lines={['1,4,9', '2,5,10', '6-7']} size="xs">
	```yaml
	- name: Checkout Repo Code
	  uses: actions/checkout@v3

	- name: Setup Node
	  uses: actions/setup-node@v3
	  with:
	    node-version: 18

	- name: Install Node Modules
	  run: npm install
	```
	<Notes slot="notes">
		- But for now we're going to have 3 steps to get started
	</Notes>
</Slide>

<Slide 
	type="figure" 
	image={ActionsDashboard} 
	caption="Repo ‚Üí Actions"
	reverse
>
	<Notes slot="notes">
		- When we have workflow files 
	</Notes>
</Slide>

<Slide type="code" size="xs" lines={['3', '5', '7-10', '12']}>
	```bash
	#!/bin/bash

	COMMAND="netlify deploy --build --site ${SITE_ID} --auth ${TOKEN} --json"

	OUTPUT=$($COMMAND)

	NETLIFY_URL=$(jq -r '.deploy_url' <<<"${OUTPUT}")
	NETLIFY_LOGS=$(jq -r '.logs' <<<"${OUTPUT}")
	DEPLOY_ID=$(jq -r '.deploy_id' <<<"${OUTPUT}")
	SITE_NAME=$(jq -r '.site_name' <<<"${OUTPUT}")

	echo "NETLIFY_URL=${NETLIFY_URL}" >> $GITHUB_OUTPUT
	```
	<Notes slot="notes">
		1. Here we'll set the command to run, this is using the Netlify CLI using the deploy command. We'll pass in the environment variables for the site and auth token, and have set the output to come through as JSON
			- https://cli.netlify.com/commands/deploy
		2. Next we'll run the command, and save the output in another variable so we can access it
		3. To parse the output from Netlify, the jq package allows us to fetch the different properties and save them as individual variables.
			- https://stedolan.github.io/jq/
		4. Lastly we'll save the Netlify preview URL as an output parameter for the workflow step, so we can access it in future steps, eg. to add it as a comment on our PR
			- https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-output-parameter
	</Notes>
</Slide>

<Slide type="code" size="xs" lines={['2', '3-5', '6']}>
	```yaml
	- name: Deploy to Netlify
	  id: build_site
	  env:
	    TOKEN: ${{ secrets.TOKEN }}
		SITE_ID: ${{ secrets.SITE_ID }}
	  run: ./.github/actions/netlify_deploy.sh
	```
	<Notes slot="notes">
		1. If we add an ID to our step, it can be referred to elsewhere in our workflow, this ID must be unique
			- https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsid
		2. For this step we also need to use some environment variables, which we're pulling in from GitHub Secrets
			- https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsenv
		3. This step will run a command in the terminal, which runs a custom script we'll create to build and deploy the site
	</Notes>
</Slide>


<Slide 
	type="figure" 
	image={ActionsSecret} 
	caption="Settings ‚Üí Secrets and variables ‚Üí Actions"
>
	<Notes slot="notes">
		- 
	</Notes>
</Slide>

<Slide 
	type="figure" 
	image={PRSuccessfulAction} 
>
	<Notes slot="notes">
		- 
	</Notes>
</Slide>

<Slide type="code" size="xs" lines={['8', '10-16']}>
	```yaml
	- name: Deploy to Netlify
	  id: build_site
	  env:
	    TOKEN: ${{ secrets.TOKEN }}
		SITE_ID: ${{ secrets.SITE_ID }}
	  run: ./.github/actions/netlify_deploy.sh

	- uses: actions/github-script@v6
	  with:
		script: |
		  github.rest.issues.createComment({
			issue_number: context.issue.number,
			owner: context.repo.owner,
			repo: context.repo.repo,
			body: 'URL: ${{steps.build_site.outputs.NETLIFY_URL}}'
		  })
	```
	<Notes slot="notes">
		1. Once the site is build, we're going to use the GitHub Script package to add a comment to our PR, so that we know everything has built and so we can easily find the preview URL if we want to check something
			- https://github.com/actions/github-script
	</Notes>
</Slide>

<Slide 
	type="figure" 
	image={WorkflowPermissions} 
	caption="Settings ‚Üí Actions ‚Üí Workflow Permissions"
>
	<Notes slot="notes">
		- 
	</Notes>
</Slide>

<Slide 
	type="figure" 
	image={SuccessfulComment}
>
	<Notes slot="notes">
		- 
	</Notes>
</Slide>

<Slide type="code" size="xs" lines={['1-6', '8-17', '12', '13', '15-17']}>
	```yaml
	- name: Deploy to Netlify
	  id: build_site
	  env:
	    TOKEN: ${{ secrets.TOKEN }}
		SITE_ID: ${{ secrets.SITE_ID }}
	  run: ./_actions/netlify_deploy.sh

	- name: Build And Deploy
      id: azure_builddeploy
      uses: Azure/static-web-apps-deploy@v1
      with:
        azure_static_web_apps_api_token: ${{ secrets.AZURE_TOKEN }}
        repo_token: ${{ secrets.GITHUB_TOKEN }} # 
        action: "upload"
        app_location: "/"
        api_location: ""
        output_location: "dist"
	```
	<Notes slot="notes">
		4. Used for Github integrations (i.e. PR comments)
		5. Repository/Build Configurations - These values can be configured to match your app requirements.
			- https://aka.ms/swaworkflowconfig
	</Notes>
</Slide>

<Slide 
	type="figure" 
	image={SuccessfulCommentMultiple}
>
	<Notes slot="notes">
		- 
	</Notes>
</Slide>

<Slide type="code" size="xs" lines={['4-5', '2-3,9-10', '9-12', '11', '13-14']}>
	```yaml
	jobs:
	  build:
		runs-on: ubuntu-22.04
		outputs:
		  deploy_url: ${{steps.build_site.outputs.NETLIFY_URL}}
		steps:
		  # Previous build steps here

	  test:
		runs-on: ubuntu-22.04
		needs: build
		steps:
		  - name: Checkout Repo Code
			uses: actions/checkout@v3
	```
	<Notes slot="notes">
		1. Because the testing job is different, we need to out the Netlify URL so we can access it in another job
			- https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idoutputs
		2. Creating a new job for the tests to run in
		3. Because the website has to have built first, we're defining a dependency on the `needs` property, that the test job needs to have the build job complete first
			- https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idneeds
		4. Jobs run in their own separate environments, so we need to checkout the repo code again so we can run tests that are defined in the repo
	</Notes>
</Slide>

{/* Add prod flag */}
<Slide type="code" size="xs">
	```bash
	#!/bin/bash

	while getopts p: flag
	do
		case "${flag}" in
			p) prod=${OPTARG};;
		esac
	done

	COMMAND="netlify deploy --build --site ${NETLIFY_SITE_ID} --auth ${NETLIFY_AUTH_TOKEN} --json"

	if [ "$prod" = "true" ]; then
		COMMAND="$COMMAND --prod"
	fi

	OUTPUT=$($COMMAND)

	NETLIFY_URL=$(jq -r '.deploy_url' <<<"${OUTPUT}")
	NETLIFY_LOGS=$(jq -r '.logs' <<<"${OUTPUT}")
	DEPLOY_ID=$(jq -r '.deploy_id' <<<"${OUTPUT}")
	SITE_NAME=$(jq -r '.site_name' <<<"${OUTPUT}")

	echo "NETLIFY_URL=${NETLIFY_URL}" >> $GITHUB_OUTPUT
	```
	<Notes slot="notes">
		- 
	</Notes>
</Slide>

<Slide 
	type="figure" 
	image={Blog} 
	caption="blog.amyskapers.dev/front-end-testing-with-github-actions"
>
	<Notes slot="notes">
		- 
	</Notes>
</Slide>

<Slide 
	type="figure" 
	image={TestingTalk} 
	caption="kapers.dev/fender-testing"
>
	<Notes slot="notes">
		- 
	</Notes>
</Slide>

<Slide>
	kapers.dev/feedback
	<Notes slot="notes">
		- 
	</Notes>
</Slide>